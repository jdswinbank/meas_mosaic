#!/usr/bin/env python

import os
import math
import numpy

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab

import lsst.afw.cameraGeom              as cameraGeom
import lsst.afw.cameraGeom.utils        as cameraGeomUtils
import lsst.afw.geom                    as afwGeom
import lsst.afw.image                   as afwImage
import lsst.afw.table                   as afwTable
import lsst.afw.coord                   as afwCoord
import lsst.afw.math                    as afwMath
import lsst.pex.config                  as pexConfig
import lsst.pipe.base                   as pipeBase
import lsst.meas.algorithms             as measAlg
import lsst.meas.astrom                 as measAstrom
import lsst.meas.mosaic.mosaicLib       as measMosaic
from lsst.pipe.tasks.colorterms import ColortermLibrary

from lsst.meas.base.forcedPhotCcd import PerTractCcdDataIdContainer

class MosaicRunner(pipeBase.TaskRunner):
    """Subclass of TaskRunner for MosaicTask

    MosaicTask.run() takes a number of arguments, one of which is a list of dataRefs
    extracted from the command line (whereas most CmdLineTasks' run methods take
    single dataRef, are are called repeatedly).  This class transforms the processed
    arguments generated by the ArgumentParser into the arguments expected by
    MosaicTask.run().

    See pipeBase.TaskRunner for more information, but note that the multiprocessing
    code path does not apply, because MosaicTask.canMultiprocess == False.
    """

    @staticmethod
    def getTargetList(parsedCmd, **kwargs):
        # organize data IDs by tract
        refListDict = {}
        for ref in parsedCmd.id.refList:
            refListDict.setdefault(ref.dataId["tract"], []).append(ref)
        # we call run() once with each tract
        return [(parsedCmd.butler.mapper.getCameraName(),
                 parsedCmd.butler,
                 tract,
                 refListDict[tract],
                 parsedCmd.debug
                 ) for tract in sorted(refListDict.keys())]

    def __call__(self, args):
        task = self.TaskClass(config=self.config, log=self.log)
        result = task.run(*args)

class MosaicConfig(pexConfig.Config):
    nBrightest = pexConfig.Field(
        doc="number of stars used for fitting per exposure",
        dtype=int,
        default=0)
    cellSize = pexConfig.Field(
        doc="size of cell used to select stars (pixels)",
        dtype=int,
        default=512,
        check = lambda x: x >= 128)
    nStarPerCell = pexConfig.Field(
        doc = "number of stars per cell",
        dtype = int,
        default = 5)
    radXMatch = pexConfig.RangeField(
        doc="radius to cross-match objects between expsoures in arcsec",
        dtype=float,
        default=1.0, min=0.1)
    fittingOrder = pexConfig.RangeField(
        doc="fitting order",
        dtype=int,
        default=5, min=2)
    internalFitting = pexConfig.Field(
        doc="Use stars without catalog matching for fitting?",
        dtype=bool,
        default=True)
    solveCcd = pexConfig.Field(
        doc="Solve CCD alignment?",
        dtype=bool,
        default=True)
    allowRotation = pexConfig.Field(
        doc="Solve rotation?",
        dtype=bool,
        default=True)
    catRMS = pexConfig.Field(
        doc="Positional error in reference catalog (degree)",
        dtype=float,
        default=0.040/3600.)
    chebyshev = pexConfig.Field(
        doc="Use Chebyshev polynomials for flux fitting?",
        dtype=bool,
        default=True)
    fluxFitOrder = pexConfig.RangeField(
        doc="flux fitting order",
        dtype=int,
        default=5, min=0)
    fluxFitAbsolute = pexConfig.Field(
        doc="Fit to catalog flux?",
        dtype=bool,
        default=False)
    fluxFitSolveCcd = pexConfig.Field(
        doc="Solve for per CCD flux scale?",
        dtype=bool,
        default=False)
    outputDir = pexConfig.Field(
        doc="Output directory to write diagnostics plots",
        dtype=str,
        default=".")
    outputDiag = pexConfig.Field(
        doc="Output diagnostics plots",
        dtype=bool,
        default=False)
    outputSnapshots = pexConfig.Field(
        doc="Output FITS tables of ObsVecs during iteration",
        dtype=bool,
        default=False)
    minNumMatch = pexConfig.RangeField(
        doc="Minimum number of matches in CCD to be used.",
        dtype=int,
        default=15, min=0)
    numSourceMerge = pexConfig.RangeField(
        doc="Minimum number of sources to be merged.",
        dtype=int,
        default=2, min=0)
    requireTractOverlap = pexConfig.Field(
        doc="If True, ignore CCDs that don't overlap the current tract",
        dtype=bool,
        default=True)
    clipSourcesOutsideTract = pexConfig.Field(
        doc="If True, unmatched sources outside of tract will not be used as constraints",
        dtype=bool,
        default=True)
    astrom = pexConfig.ConfigField(dtype=measAstrom.ANetBasicAstrometryConfig, doc="Configuration for readMatches")
    doColorTerms = pexConfig.Field(dtype=bool, default=True, doc="Apply color terms as part of solution?")
    doSolveWcs = pexConfig.Field(dtype=bool, default=True, doc="Solve distortion and wcs?")
    doSolveFlux = pexConfig.Field(dtype=bool, default=True, doc="Solve flux correction?")
    commonFluxCorr = pexConfig.Field(dtype=bool, default=True, doc="Is flux correction common between exposures?")
    colorterms = pexConfig.ConfigField(dtype=ColortermLibrary, doc="Color term library")
    photoCatName = pexConfig.Field(dtype=str, optional=True,
        doc="Name of photometric reference catalog; used to select a color term dict in colorterm library.")

def setCatFlux(m, f, key):
    m.first.set(key, f)
    return m

class MosaicTask(pipeBase.CmdLineTask):

    RunnerClass = MosaicRunner
    canMultiprocess = False
    ConfigClass = MosaicConfig
    _DefaultName = "Mosaic"

    @classmethod
    def _makeArgumentParser(cls):
        parser = pipeBase.ArgumentParser(name=cls._DefaultName)
        parser.add_id_argument("--id", "wcs", help="data ID, with raw CCD keys + tract",
                               ContainerClass=PerTractCcdDataIdContainer)
        return parser

    def readCcd(self, dataRefList):
        self.log.info("Reading CCD info ...")

        ccds = measMosaic.CcdSet()
        for dataRef in dataRefList:
            if not dataRef.dataId['ccd'] in ccds.keys():
                ccd = cameraGeomUtils.findCcd(dataRef.getButler().mapper.camera, cameraGeom.Id(int(dataRef.dataId['ccd'])))
                ccds[dataRef.dataId['ccd']] = ccd
        
        return ccds
        
    def getWcsForCcd(self, dataRef):

        try:
            md = dataRef.get('calexp_md')
            return afwImage.makeWcs(md)
        except Exception, e:
            print "Failed to read: %s for %s" % (e, dataRef.dataId)
            return None

    def readWcs(self, dataRefList, ccdSet):
        
        self.log.info("Reading WCS ...")

        wcsDic = measMosaic.WcsDic()
        for dataRef in dataRefList:
            if not dataRef.dataId['visit'] in wcsDic.keys():
                if (dataRef.datasetExists('calexp') and
                    dataRef.datasetExists('src') and
                    dataRef.datasetExists('icSrc') and
                    dataRef.datasetExists('icMatch')):
                    wcs = self.getWcsForCcd(dataRef)
                    ccd = ccdSet[dataRef.dataId['ccd']]
                    offset = ccd.getCenter().getPixels(ccd.getPixelSize())
                    wcs.shiftReferencePixel(offset[0], offset[1])
                    wcsDic[dataRef.dataId['visit']] = wcs

        return wcsDic

    def removeNonExistCcd(self, dataRefList, ccdSet):
        num = dict()
        for dataRef in dataRefList:
            if not dataRef.dataId['ccd'] in num.keys():
                num[dataRef.dataId['ccd']] = 0
            if (dataRef.datasetExists('calexp') and
                dataRef.datasetExists('src') and
                dataRef.datasetExists('icSrc') and
                dataRef.datasetExists('icMatch')):
                num[dataRef.dataId['ccd']] += 1

        for ichip in ccdSet.keys():
            if num[ichip] == 0:
                ccdSet.erase(ichip)
            
    def selectStars(self, sources, includeSaturated=False):
        if len(sources) == 0:
            return []
        if isinstance(sources, afwTable.SourceCatalog):
            extended = sources.columns["classification.extendedness"]
            saturated = sources.columns["flags.pixel.saturated.any"]
            try:
                nchild = sources.columns["deblend.nchild"]
            except:
                nchild = numpy.zeros(len(sources))
            indices = numpy.where(numpy.logical_and(numpy.logical_and(extended < 0.5, saturated == False), nchild == 0))[0]
            return [sources[int(i)] for i in indices]

        psfKey = None                       # Table key for classification.psfstar
        if isinstance(sources, afwTable.ReferenceMatchVector) or isinstance(sources[0], afwTable.ReferenceMatch):
            sourceList = [s.second for s in sources]
            psfKey = sourceList[0].schema.find("calib.psf.used").getKey()
        else:
            sourceList = sources

        schema = sourceList[0].schema
        extKey = schema.find("classification.extendedness").getKey()
        satKey = schema.find("flags.pixel.saturated.any").getKey()

        stars = []
        for includeSource, checkSource in zip(sources, sourceList):
            star = (psfKey is not None and checkSource.get(psfKey)) or checkSource.get(extKey) < 0.5
            saturated = checkSource.get(satKey)
            if star and (includeSaturated or not saturated):
                stars.append(includeSource)
        return stars

    def getAllForCcd(self, dataRef, astrom, ct=None, verbose=False):
        try:
            if not dataRef.datasetExists('src'):
                raise RuntimeError("no data for src %s" % (dataRef.dataId))
            if not dataRef.datasetExists('calexp_md'):
                raise RuntimeError("no data for calexp_md %s" % (dataRef.dataId))
            md = dataRef.get('calexp_md', immediate=True)
            wcs = afwImage.makeWcs(md)
            filterName = afwImage.Filter(md).getName()

            sources = dataRef.get('src', immediate=True, flags=afwTable.SOURCE_IO_NO_FOOTPRINTS)
            if False:
                matches = measAstrom.readMatches(dataRef.getButler(), dataRef.dataId, config=self.config.astrom)
            else:
                if False: #dataRef.datasetExists('icMatchFull'):
                    if verbose:
                        self.log.info("Reading matches from icMatchFull files for %s" % dataRef.dataId)
                                  
                    matchFull = dataRef.get('icMatchFull', immediate=True)
                    matches = measMosaic.matchesFromCatalog(matchFull)
                    #for slot in ("PsfFlux", "ModelFlux", "ApFlux", "InstFlux", "Centroid", "Shape"):
                    #    getattr(matches[0].second.getTable(), "define" + slot)(getattr(icSrces, "get" + slot + "Definition")())
                    table = matches[0].second.getTable()
                    table.definePsfFlux('flux.psf')
                    table.defineModelFlux('flux.gaussian')
                    table.defineApFlux('flux.sinc')
                    table.defineInstFlux('flux.gaussian')
                    table.defineCentroid('centroid.sdss')
                    table.defineShape('shape.sdss')
                else:
                    if verbose:
                        self.log.info("Reading matches from icSrc files for %s" % dataRef.dataId)
                    icSrces = dataRef.get('icSrc', immediate=True)
                    packedMatches = dataRef.get('icMatch', immediate=True)
                    matches = astrom.joinMatchListWithCatalog(packedMatches, icSrces)

                matches = [m for m in matches if m.first != None]

                if matches:
                    refSchema = matches[0].first.schema
                    if ct:
                        # Add a "flux" field to the match records which contains the
                        # colorterm-corrected reference flux. The field name is hard-coded in
                        # lsst::meas::mosaic::Source.
                        mapper = afwTable.SchemaMapper(refSchema)
                        for key, field in refSchema:
                            mapper.addMapping(key)
                        key_f = mapper.editOutputSchema().addField("flux", type=float, doc="Reference flux")
                        table = afwTable.SimpleTable.make(mapper.getOutputSchema())
                        table.preallocate(len(matches))
                        for match in matches:
                            newMatch = table.makeRecord()
                            newMatch.assign(match.first, mapper)
                            match.first = newMatch

                        key_p = refSchema.find(refSchema.join(ct.primary, "flux")).key
                        key_s = refSchema.find(refSchema.join(ct.secondary, "flux")).key
                        refFlux1 = numpy.array([m.first.get(key_p) for m in matches])
                        refFlux2 = numpy.array([m.first.get(key_s) for m in matches])
                        refMag1 = -2.5*numpy.log10(refFlux1)
                        refMag2 = -2.5*numpy.log10(refFlux2)
                        refMag = ct.transformMags(refMag1, refMag2)
                        refFlux = numpy.power(10.0, -0.4*refMag)
                        matches = [setCatFlux(m, f, key_f) for m, f in zip(matches, refFlux) if f == f]
                    else:
                        # No colorterm; we can get away with aliasing the reference flux.
                        refFluxField = measAlg.getRefFluxField(refSchema, filterName)
                        refSchema.getAliasMap().set("flux", refFluxField)

            selSources = self.selectStars(sources)
            selMatches = self.selectStars(matches)
            #if len(selMatches) < 10:
            #    selMatches = self.selectStars(matches, True)
        except Exception, e:
            self.log.warn("Failed to read %s: %s" % (dataRef.dataId, e))
            return None, None, None
    
        return selSources, selMatches, wcs

    def readCatalog(self, dataRefList, ct=None, verbose=False):
        self.log.info("Reading catalogs ...")

        sourceSet = measMosaic.SourceGroup()
        matchList = measMosaic.SourceMatchGroup()
        astrom = measAstrom.ANetBasicAstrometryTask(self.config.astrom)

        ssVisit = dict()
        mlVisit = dict()
        dataRefListUsed = list()
        for dataRef in dataRefList:
            #self.log.info('%d %d' % (dataRef.dataId['visit'], dataRef.dataId['ccd']))
            sources, matches, wcs = self.getAllForCcd(dataRef, astrom, ct, verbose)
            if sources != None:
                if len(matches) > self.config.minNumMatch:
                    if not dataRef.dataId['visit'] in ssVisit.keys():
                        ssVisit[dataRef.dataId['visit']] = list()
                        mlVisit[dataRef.dataId['visit']] = list()
                    calexp_md = dataRef.get('calexp_md')
                    naxis1, naxis2 = calexp_md.get('NAXIS1'), calexp_md.get('NAXIS2')
                    bbox = afwGeom.Box2I(afwGeom.Point2I(0,0), afwGeom.Extent2I(naxis1, naxis2))
                    cellSet = afwMath.SpatialCellSet(bbox, self.config.cellSize, self.config.cellSize)
                    for s in sources:
                        if numpy.isfinite(s.getRa().asDegrees()): # get rid of NaN
                            src = measMosaic.Source(s)
                            src.setExp(dataRef.dataId['visit'])
                            src.setChip(dataRef.dataId['ccd'])
                            try:
                                cellSet.insertCandidate(measMosaic.SpatialCellSource(src))
                            except Exception, e:
                                self.log.info('visit=%d ccd=%d x=%f y=%f' % (dataRef.dataId['visit'], dataRef.dataId['ccd'], src.getX(), src.getY()) + ' bbox=' + str(bbox))
                            #ssVisit[dataRef.dataId['visit']].append(src)
                    for cell in cellSet.getCellList():
                        cell.sortCandidates()
                        for i, cand in enumerate(cell):
                            cand = measMosaic.cast_SpatialCellSource(cand)
                            src = cand.getSource()
                            ssVisit[dataRef.dataId['visit']].append(src)
                            if i == self.config.nStarPerCell-1:
                                break
                    #print dataRef.dataId['visit'], len(ssVisit[dataRef.dataId['visit']])
                    for m in matches:
                        if m.first != None and m.second != None:
                            match = measMosaic.SourceMatch(measMosaic.Source(m.first, wcs), measMosaic.Source(m.second))
                            match.second.setExp(dataRef.dataId['visit'])
                            match.second.setChip(dataRef.dataId['ccd'])
                            mlVisit[dataRef.dataId['visit']].append(match)
                    dataRefListUsed.append(dataRef)
                else:
                    self.log.info('%8d %3d : %2d matches  Suspicious to wrong match. Ignore this CCD' % (dataRef.dataId['visit'], dataRef.dataId['ccd'], len(matches)))

        for visit in ssVisit.keys():
            sourceSet.push_back(ssVisit[visit])
            matchList.push_back(mlVisit[visit])

        return sourceSet, matchList, dataRefListUsed

    def countObsInSourceGroup(self, sg):
        num = 0
        for s in sg:
            num += (len(s) - 1)

        return num

    def mergeCatalog(self, sourceSet, matchList, ccdSet, d_lim):

        self.log.info("Creating kd-tree for matched catalog ...")
        self.log.info("len(matchList) = "+str(len(matchList))+" "+
                      str([len(matches) for matches in matchList]))
        rootMat = measMosaic.kdtreeMat(matchList)
        allMat = rootMat.mergeMat()
        self.log.info("# of allMat : %d" % self.countObsInSourceGroup(allMat))
        self.log.info('len(allMat) = %d' % len(allMat))
    
        self.log.info("Creating kd-tree for source catalog ...")
        self.log.info('len(sourceSet) = '+str(len(sourceSet))+" "+
                      str([len(sources) for sources in sourceSet]))
        rootSource = measMosaic.kdtreeSource(sourceSet, rootMat, ccdSet, d_lim)
        allSource = rootSource.mergeSource(self.config.numSourceMerge)
        self.log.info("# of allSource : %d" % self.countObsInSourceGroup(allSource))
        self.log.info('len(allSource) = %d' % len(allSource))

        return allMat, allSource

    def writeNewWcs(self, dataRefList):
        self.log.info("Write New WCS ...")
        exp = afwImage.ExposureI(0,0)
        for dataRef in dataRefList:
            iexp = dataRef.dataId['visit']
            ichip = dataRef.dataId['ccd']
            c = measMosaic.convertCoeff(self.coeffSet[iexp], self.ccdSet[ichip]);
            wcs = measMosaic.wcsFromCoeff(c);
            exp.setWcs(wcs)
            try:
                dataRef.put(exp, 'wcs')
            except Exception, e:
                print "failed to write something: %s" % (e)

    def writeFcr(self, dataRefList):
        self.log.info("Write Fcr ...")
        M_LN10 = math.log(10)
        dmag = list()
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1 and
                m.mag0 != -9999 and m.mag_cat != -9999):
                mag = m.mag
                mag0 = m.mag0
                mag_cat = m.mag_cat
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                dmag.append(mag_cor - mag_cat)
        std, mean, n  = self.clippedStd(numpy.array(dmag), 3)
        for dataRef in dataRefList:
            iexp = dataRef.dataId['visit']
            ichip = dataRef.dataId['ccd']
            try:
                x0 = self.coeffSet[iexp].x0
                y0 = self.coeffSet[iexp].y0
            except Exception, e:
                x0 = 0.0
                y0 = 0.0
            newP = measMosaic.convertFluxFitParams(measMosaic.FluxFitParams(self.ffpSet[iexp]),
                                                   self.ccdSet[ichip], x0, y0)
            metadata = measMosaic.metadataFromFluxFitParams(newP)
            exp = afwImage.ExposureI(0,0)
            exp.getMetadata().combine(metadata)
            scale = self.fexp[iexp] * self.fchip[ichip]
            calib = afwImage.Calib()
            calib.setFluxMag0(1.0/scale, 1.0/scale*std*M_LN10*0.4)
            exp.setCalib(calib)
            try:
                dataRef.put(exp, 'fcr')
            except Exception, e:
                print "failed to write something: %s" % (e)

    def getExtent(self, matchVec):
        u_max = float("-inf")
        v_max = float("-inf")
        for m in matchVec:
            if (math.fabs(m.u) > u_max):
                u_max = math.fabs(m.u)
            if (math.fabs(m.v) > v_max):
                v_max = math.fabs(m.v)

        return u_max, v_max

    def plotCcd(self, coeffx0=0, coeffy0=0):
        for ccd in self.ccdSet.values():
            w = ccd.getAllPixels(True).getWidth()
            h = ccd.getAllPixels(True).getHeight()
            us = list()
            vs = list()
            for x, y in zip([0, w, w, 0, 0], [0, 0, h, h, 0]):
                xy = afwGeom.Point2D(x, y)
                u, v = ccd.getPositionFromPixel(xy).getPixels(ccd.getPixelSize())
                us.append(u)
                vs.append(v)
            plt.plot(us, vs, 'k-')

    def plotJCont(self, iexp):
        coeff = self.coeffSet[iexp]

        scale = coeff.pixelScale()
        deg2pix = 1. / scale

        delta = 300.
        if (self.ccdSet.size() >= 100):
            x = numpy.arange(-18000., 18000., delta)
            y = numpy.arange(-18000., 18000., delta)
            levels = numpy.linspace(0.81, 1.02, 36)
        else:
            x = numpy.arange(-6000., 6000., delta)
            y = numpy.arange(-6000., 6000., delta)
            levels = numpy.linspace(0.88, 1.02, 36)
        X, Y = numpy.meshgrid(x, y)
        Z = numpy.zeros((len(X),len(Y)))

        for j in range(len(Y)):
            for i in range(len(X)):
                Z[i][j] = coeff.detJ(X[i][j], Y[i][j]) * deg2pix ** 2

        plt.clf()
        plt.contourf(X, Y, Z, levels=levels)
        plt.colorbar()
        plt.title('%d' % (iexp))

        self.plotCcd(coeff.x0, coeff.y0)

        plt.savefig(os.path.join(self.outputDir, "jcont_%d.png" % (iexp)), format='png')

    def plotFCorCont(self, iexp):
        delta = 300.
        if (self.ccdSet.size() > 10):
            x = numpy.arange(-18000., 18000., delta)
            y = numpy.arange(-18000., 18000., delta)
#            levels = numpy.linspace(0.81, 1.02, 36)
            levels = numpy.linspace(0.72, 1.28, 36)
        else:
            x = numpy.arange(-6000., 6000., delta)
            y = numpy.arange(-6000., 6000., delta)
            levels = numpy.linspace(0.86, 1.14, 36)
        X, Y = numpy.meshgrid(x, y)
        Z = numpy.zeros((len(X),len(Y)))

        for j in range(len(Y)):
            for i in range(len(X)):
                Z[i][j] = 10**(-0.4*self.ffpSet[iexp].eval(X[i][j], Y[i][j]))
        mean = math.floor(Z[len(X)/2][len(Y)/2] * 10 + 0.5) / 10.
        levels = numpy.linspace(mean-0.2, mean+0.2, 41)

        plt.clf()
        plt.contourf(X, Y, Z, levels=levels)
        plt.colorbar()
        plt.title('%d' % (iexp))

        try:
            x0 = self.coeffSet[iexp].x0
            y0 = self.coeffSet[iexp].y0
        except Exception, e:
            x0 = 0.0
            y0 = 0.0
        self.plotCcd(x0, y0)
        
        plt.savefig(os.path.join(self.outputDir, "fcont_%d.png" % (iexp)), format='png')

    def plotResPosArrow2D(self, iexp):
        _xm = []
        _ym = []
        _dxm = []
        _dym = []
        for m in self.matchVec:
            if (m.good == True and m.iexp == iexp):
                _xm.append(m.u)
                _ym.append(m.v)
                _dxm.append((m.xi_fit - m.xi) * 3600)
                _dym.append((m.eta_fit - m.eta) * 3600)
        _xs = []
        _ys = []
        _dxs = []
        _dys = []
        if (self.sourceVec.size() != 0):
            for s in self.sourceVec:
                if (s.good == True and s.iexp == iexp):
                    _xs.append(s.u)
                    _ys.append(s.v)
                    _dxs.append((s.xi_fit - s.xi) * 3600)
                    _dys.append((s.eta_fit - s.eta) * 3600)

        xm = numpy.array(_xm)
        ym = numpy.array(_ym)
        dxm = numpy.array(_dxm)
        dym = numpy.array(_dym)
        xs = numpy.array(_xs)
        ys = numpy.array(_ys)
        dxs = numpy.array(_dxs)
        dys = numpy.array(_dys)

        plt.clf()
        plt.rc('text', usetex=True)

        q = plt.quiver(xm, ym, dxm, dym, units='inches', angles='xy', scale=1, color='green')
        if len(ym) != 0 and ym.max() > 5000:
            plt.quiverkey(q, 0, 19000, 0.1, "0.1 arcsec", coordinates='data', color='black')
        else:
            plt.quiverkey(q, 0,  4500, 0.1, "0.1 arcsec", coordinates='data', color='black')
        plt.quiver(xs, ys, dxs, dys, units='inches', angles='xy', scale=1, color='red')

        self.plotCcd(self.coeffSet[iexp].x0, self.coeffSet[iexp].y0)
        plt.axes().set_aspect('equal')

        plt.savefig(os.path.join(self.outputDir, "ResPosArrow2D_%d.png" % (iexp)), format='png')

    def clippedStd(self, a, n):
        aa = list()
        for v in a:
            if v == v:
                aa.append(v)
        aa = numpy.array(aa)

        avg = aa.mean()
        std = aa.std()
        for i in range(n):
            b = aa[numpy.fabs(aa-avg) < 2.1*std]
            avg = b.mean()
            std = b.std()

        b = aa[numpy.fabs(aa-avg) < 2.1*std]
        avg = b.mean()
        std = b.std()
            
        return [std, avg, len(b)]

    def plotResPosScatter(self):
        _x = []
        _y = []
        _xbad = []
        _ybad = []
        _xm = []
        _ym = []
        f = open(os.path.join(self.outputDir, "dpos.dat"), "wt")
        for m in self.matchVec:
            if (m.good == True):
                _x.append((m.xi_fit - m.xi) * 3600)
                _y.append((m.eta_fit - m.eta) * 3600)
                _xm.append((m.xi_fit - m.xi) * 3600)
                _ym.append((m.eta_fit - m.eta) * 3600)
                f.write("m %f %f %f %f %f %f 1\n" % (m.xi_fit, m.eta_fit,
                                                     m.xi, m.eta, m.u, m.v))
            else:
                _xbad.append((m.xi_fit - m.xi) * 3600)
                _ybad.append((m.eta_fit - m.eta) * 3600)
                f.write("m %f %f %f %f %f %f 0\n" % (m.xi_fit, m.eta_fit,
                                                     m.xi, m.eta, m.u, m.v))
        _xs = []
        _ys = []
        if (self.sourceVec.size() != 0):
            for s in self.sourceVec:
                if (s.good == True):
                    _x.append((s.xi_fit - s.xi) * 3600)
                    _y.append((s.eta_fit - s.eta) * 3600)
                    _xs.append((s.xi_fit - s.xi) * 3600)
                    _ys.append((s.eta_fit - s.eta) * 3600)
                    f.write("s %f %f %f %f %f %f 1\n" % (s.xi_fit, s.eta_fit,
                                                         s.xi, s.eta, s.u, s.v))
                else:
                    _xbad.append((s.xi_fit - s.xi) * 3600)
                    _ybad.append((s.eta_fit - s.eta) * 3600)
                    f.write("s %f %f %f %f %f %f 0\n" % (s.xi_fit, s.eta_fit,
                                                         s.xi, s.eta, s.u, s.v))
        f.close()

        d_xi = numpy.array(_x)
        d_eta = numpy.array(_y)
        d_xi_m = numpy.array(_xm)
        d_eta_m = numpy.array(_ym)
        d_xi_s = numpy.array(_xs)
        d_eta_s = numpy.array(_ys)
        d_xi_bad = numpy.array(_xbad)
        d_eta_bad = numpy.array(_ybad)

        xi_std,  xi_mean,  xi_n  = self.clippedStd(d_xi, 2)
        eta_std, eta_mean, eta_n = self.clippedStd(d_eta, 2)
        xi_std_m,  xi_mean_m,  xi_n_m  = self.clippedStd(d_xi_m, 2)
        eta_std_m, eta_mean_m, eta_n_m = self.clippedStd(d_eta_m, 2)
        xi_std_s,  xi_mean_s,  xi_n_s  = self.clippedStd(d_xi_s, 2)
        eta_std_s, eta_mean_s, eta_n_s = self.clippedStd(d_eta_s, 2)

        plt.clf()
        plt.rc('text', usetex=True)

        plt.subplot2grid((5,6),(1,0), colspan=4, rowspan=4)
        plt.plot(d_xi_bad, d_eta_bad, 'k,', markeredgewidth=0)
        plt.plot(d_xi_m, d_eta_m, 'g,', markeredgewidth=0)
        plt.plot(d_xi_s, d_eta_s, 'r,', markeredgewidth=0)
        plt.xlim(-0.5, 0.5)
        plt.ylim(-0.5, 0.5)

        plt.xlabel(r'$\Delta\xi$ (arcsec)')
        plt.ylabel(r'$\Delta\eta$ (arcsec)')

        bins = numpy.arange(-0.5, 0.5, 0.01) + 0.005

        ax = plt.subplot2grid((5,6),(0,0), colspan=4)
        if self.sourceVec.size() != 0:
            plt.hist([d_xi, d_xi_m, d_xi_s], bins=bins, normed=False, histtype='step')
        else:
            plt.hist([d_xi, d_xi_m], bins=bins, normed=False, histtype='step')
        plt.text(0.75, 0.7, r"$\sigma=$%5.3f" % (xi_std), transform=ax.transAxes, color='blue')
        plt.text(0.75, 0.5, r"$\sigma=$%5.3f" % (xi_std_m), transform=ax.transAxes, color='green')
        y = mlab.normpdf(bins, xi_mean_m, xi_std_m)
        plt.plot(bins, y*xi_n_m*0.01, 'g:')
        if self.sourceVec.size() != 0:
            plt.text(0.75, 0.3, r"$\sigma=$%5.3f" % (xi_std_s), transform=ax.transAxes, color='red')
            y = mlab.normpdf(bins, xi_mean_s, xi_std_s)
            plt.plot(bins, y*xi_n_s*0.01, 'r:')
        plt.xlim(-0.5, 0.5)

        ax = plt.subplot2grid((5,6),(1,4), rowspan=4)
        plt.hist(d_eta, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.hist(d_eta_m, bins=bins, normed=False, orientation='horizontal', histtype='step')
        if self.sourceVec.size() != 0:
            plt.hist(d_eta_s, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.text(0.7, 0.25, r"$\sigma=$%5.3f" % (eta_std), rotation=270, transform=ax.transAxes, color='blue')
        plt.text(0.5, 0.25, r"$\sigma=$%5.3f" % (eta_std_m), rotation=270, transform=ax.transAxes, color='green')
        y = mlab.normpdf(bins, eta_mean_m, eta_std_m)
        plt.plot(y*eta_n_m*0.01, bins, 'g:')
        if self.sourceVec.size() != 0:
            plt.text(0.3, 0.25, r"$\sigma=$%5.3f" % (eta_std_s), rotation=270, transform=ax.transAxes, color='red')
            y = mlab.normpdf(bins, eta_mean_s, eta_std_s)
            plt.plot(y*eta_n_s*0.01, bins, 'r:')
        plt.xticks(rotation=270)
        plt.yticks(rotation=270)
        plt.ylim(-0.5, 0.5)

        plt.savefig(os.path.join(self.outputDir, "ResPosScatter.png"), format='png')

    def plotMdM(self):
        _dmag_m = []
        _dmag_cat_m = []
        _dmag_s = []
        _dmag_a = []
        _dmag_bad = []
        _dmag_cat_bad = []
        _mag0_m = []
        _mag_cat_m = []
        _mag0_s = []
        _mag0_bad = []
        _mag_cat_bad = []
        f = open(os.path.join(self.outputDir, 'dmag.dat'), 'wt')
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1 and m.mag0 != -9999 and m.mag_cat != -9999):
                mag = m.mag
                mag0 = m.mag0
                mag_cat = m.mag_cat
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag_m.append(diff)
                _dmag_a.append(diff)
                _mag0_m.append(mag0)
                _dmag_cat_m.append(mag_cor - mag_cat)
                _mag_cat_m.append(mag_cat)
                f.write("m %f %f %f %f %f 1\n" % (mag_cor, mag0, mag_cat,
                                                  m.u, m.v))
            else:
                mag = m.mag
                mag0 = m.mag0
                mag_cat = m.mag_cat
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag_bad.append(diff)
                _mag0_bad.append(mag0)
                _dmag_cat_bad.append(mag_cor - mag_cat)
                _mag_cat_bad.append(mag_cat)
                f.write("m %f %f %f %f %f 0\n" % (mag_cor, mag0, mag_cat,
                                                  m.u, m.v))
        if self.sourceVec.size() != 0:
            for s in self.sourceVec:
                if (s.good == True and s.mag != -9999 and s.jstar != -1):
                    mag = s.mag
                    mag0 = s.mag0
                    exp_cor = -2.5 * math.log10(self.fexp[s.iexp])
                    chip_cor = -2.5 * math.log10(self.fchip[s.ichip])
                    gain_cor = self.ffpSet[s.iexp].eval(s.u, s.v)
                    mag_cor = mag + exp_cor + chip_cor + gain_cor
                    diff = mag_cor - mag0
                    _dmag_s.append(diff)
                    _dmag_a.append(diff)
                    _mag0_s.append(mag0)
                    f.write("s %f %f %f %f %f 1\n" % (mag_cor, mag0, -9999,
                                                      s.u, s.v))
                else:
                    mag = s.mag
                    mag0 = s.mag0
                    exp_cor = -2.5 * math.log10(self.fexp[s.iexp])
                    chip_cor = -2.5 * math.log10(self.fchip[s.ichip])
                    gain_cor = self.ffpSet[s.iexp].eval(s.u, s.v)
                    mag_cor = mag + exp_cor + chip_cor + gain_cor
                    diff = mag_cor - mag0
                    _dmag_bad.append(diff)
                    _mag0_bad.append(mag0)
                    f.write("s %f %f %f %f %f 0\n" % (mag_cor, mag0, -9999,
                                                      s.u, s.v))
        f.close()

        d_mag_m = numpy.array(_dmag_m)
        d_mag_cat_m = numpy.array(_dmag_cat_m)
        d_mag_s = numpy.array(_dmag_s)
        d_mag_a = numpy.array(_dmag_a)
        d_mag_bad = numpy.array(_dmag_bad)
        d_mag_cat_bad = numpy.array(_dmag_cat_bad)
        mag0_m = numpy.array(_mag0_m)
        mag_cat_m = numpy.array(_mag_cat_m)
        mag0_s = numpy.array(_mag0_s)
        mag0_bad = numpy.array(_mag0_bad)
        mag_cat_bad = numpy.array(_mag_cat_bad)

        mag_std_m, mag_mean_m, mag_n_m  = self.clippedStd(d_mag_m, 3)
        mag_std_s, mag_mean_s, mag_n_s  = self.clippedStd(d_mag_s, 3)
        mag_std_a, mag_mean_a, mag_n_a  = self.clippedStd(d_mag_a, 3)
        mag_cat_std_m, mag_cat_mean_m, mag_cat_n_m  = self.clippedStd(d_mag_cat_m, 3)

        plt.clf()
        plt.rc('text', usetex=True)

        plt.subplot2grid((5,6),(1,0), colspan=4, rowspan=4)
        plt.plot(mag0_bad, d_mag_bad, 'k,', markeredgewidth=0)
        plt.plot(mag_cat_m, d_mag_cat_m, 'c,', markeredgewidth=0)
        if self.sourceVec.size() != 0:
            plt.plot(mag0_s, d_mag_s, 'r,', markeredgewidth=0)
        plt.plot(mag0_m, d_mag_m, 'g,', markeredgewidth=0)
        plt.plot([15,25], [0,0], 'k--')
        plt.xlim(15, 25)
        plt.ylim(-0.25, 0.25)
        plt.ylabel(r'$\Delta mag$ (mag)')

        bins = numpy.arange(-0.25, 0.25, 0.005) + 0.0025
        bins2 = numpy.arange(-0.25, 0.25, 0.05) + 0.025

        ax = plt.subplot2grid((5,6),(1,4), rowspan=4)
        plt.hist(d_mag_a, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.hist(d_mag_m, bins=bins, normed=False, orientation='horizontal', histtype='step')
        if self.sourceVec.size() != 0:
            plt.hist(d_mag_s, bins=bins, normed=False, orientation='horizontal', histtype='step')
        plt.hist(d_mag_cat_m, bins=bins2, normed=False, orientation='horizontal', histtype='step')
        plt.text(0.7, 0.25, r"$\sigma=$%5.3f" % (mag_std_a), rotation=270, transform=ax.transAxes, color='blue')
        plt.text(0.5, 0.25, r"$\sigma=$%5.3f" % (mag_std_m), rotation=270, transform=ax.transAxes, color='green')
        plt.text(0.7, 0.90, r"$\sigma=$%5.3f" % (mag_cat_std_m), rotation=270, transform=ax.transAxes, color='cyan')
        y = mlab.normpdf(bins, mag_mean_m, mag_std_m)
        plt.plot(y*mag_n_m*0.005, bins, 'g:')
        if self.sourceVec.size() != 0:
            plt.text(0.3, 0.25, r"$\sigma=$%5.3f" % (mag_std_s), rotation=270, transform=ax.transAxes, color='red')
            y = mlab.normpdf(bins, mag_mean_s, mag_std_s)
            plt.plot(y*mag_n_s*0.005, bins, 'r:')
        y = mlab.normpdf(bins, mag_cat_mean_m, mag_cat_std_m)
        plt.plot(y*mag_cat_n_m*0.05, bins, 'c:')
        plt.xticks(rotation=270)
        plt.yticks(rotation=270)
        plt.ylim(-0.25, 0.25)

        plt.savefig(os.path.join(self.outputDir, "MdM.png"), format='png')

    def plotPosDPos(self):
        _xi = []
        _eta = []
        _x = []
        _y = []
        for m in self.matchVec:
            if (m.good == True):
                _x.append((m.xi_fit - m.xi) * 3600)
                _y.append((m.eta_fit - m.eta) * 3600)
                _xi.append(m.xi * 3600)
                _eta.append(m.eta * 3600)
        if (self.sourceVec.size() != 0):
            for s in self.sourceVec:
                if (s.good == True):
                    _x.append((s.xi_fit - s.xi) * 3600)
                    _y.append((s.eta_fit - s.eta) * 3600)
                    _xi.append(s.xi * 3600)
                    _eta.append(s.eta * 3600)

        xi = numpy.array(_xi)
        eta = numpy.array(_eta)
        d_xi = numpy.array(_x)
        d_eta = numpy.array(_y)

        plt.clf()
        plt.rc('text', usetex=True)

        plt.subplot(2, 2, 1)
        plt.plot(xi, d_xi, ',', markeredgewidth=0)
        plt.xlabel(r'$\xi$ (arcsec)')
        plt.ylabel(r'$\Delta\xi$ (arcsec)')

        plt.subplot(2, 2, 3)
        plt.plot(xi, d_eta, ',', markeredgewidth=0)
        plt.xlabel(r'$\xi$ (arcsec)')
        plt.ylabel(r'$\Delta\eta$ (arcsec)')

        plt.subplot(2, 2, 2)
        plt.plot(eta, d_xi, ',', markeredgewidth=0)
        plt.xlabel(r'$\eta$ (arcsec)')
        plt.ylabel(r'$\Delta\xi$ (arcsec)')

        plt.subplot(2, 2, 4)
        plt.plot(eta, d_xi, ',', markeredgewidth=0)
        plt.xlabel(r'$\eta$ (arcsec)')
        plt.ylabel(r'$\Delta\eta$ (arcsec)')

        plt.savefig(os.path.join(self.outputDir, "PosDPos.png"), format='png')

    def plotResFlux(self):
        _dmag = []
        _iexp = []
        _ichip = []
        _r = []
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1):
                mag = m.mag
                mag0 = m.mag0
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag.append(diff)
                _iexp.append(m.iexp)
                _ichip.append(m.ichip)

        d_mag = numpy.array(_dmag)
        iexp = numpy.array(_iexp)
        ichip = numpy.array(_ichip)

        mag_std = self.clippedStd(d_mag, 3)[0]

        _r = []
        _dm = []
        for ccd in self.ccdSet.values():
            w = ccd.getAllPixels(True).getWidth()
            h = ccd.getAllPixels(True).getHeight()
            _x0 = ccd.getCenter().getPixels(ccd.getPixelSize())[0] + 0.5 * w
            _y0 = ccd.getCenter().getPixels(ccd.getPixelSize())[1] + 0.5 * h
            _r.append(math.sqrt(_x0*_x0 + _y0*_y0))
            _dm.append(-2.5 * math.log10(self.fchip[ccd.getId().getSerial()]))

        r = numpy.array(_r)
        dm = numpy.array(_dm)

        plt.clf()
        plt.rc('text', usetex=True)

        ax = plt.subplot(2, 2, 1)
        plt.hist(d_mag, bins=100, normed=True, histtype='step')
        plt.text(0.1, 0.7, r"$\sigma=$%7.5f" % (mag_std), transform=ax.transAxes)
        plt.xlabel(r'$\Delta mag$ (mag)')

        ax = plt.subplot(2, 2, 2)
        plt.plot(r, dm, 'o')
        plt.xlabel(r'Distance from center (pixel)')
        plt.ylabel(r'Offset in magnitude')

        ax = plt.subplot(2, 2, 3)
        plt.plot(iexp, d_mag, ',', markeredgewidth=0)
        plt.xlabel(r'Exposure ID')
        plt.ylabel(r'$\Delta mag$ (mag)')
        plt.xlim(iexp.min()-1, iexp.max()+1)
        plt.ylim(-0.2, 0.2)

        ax = plt.subplot(2, 2, 4)
        plt.plot(ichip, d_mag, ',', markeredgewidth=0)
        plt.xlabel(r'Chip ID')
        plt.ylabel(r'$\Delta mag$ (mag)')
        plt.xlim(ichip.min()-1, ichip.max()+1)
        plt.ylim(-0.2, 0.2)

        plt.savefig(os.path.join(self.outputDir, "ResFlux.png"), format='png')

    def plotDFlux2D(self):
        _dmag = []
        _u = []
        _v = []
        for m in self.matchVec:
            if (m.good == True and m.mag != -9999 and m.jstar != -1):
                mag = m.mag
                mag0 = m.mag0
                exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
                chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
                gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
                mag_cor = mag + exp_cor + chip_cor + gain_cor
                diff = mag_cor - mag0
                _dmag.append(diff)
                _u.append(m.u)
                _v.append(m.v)

        d_mag = numpy.array(_dmag)
        u = numpy.array(_u)
        v = numpy.array(_v)

        s = numpy.absolute(d_mag) * 10

        u1 = [u[i] for i in range(len(d_mag)) if d_mag[i] > 0]
        v1 = [v[i] for i in range(len(d_mag)) if d_mag[i] > 0]
        s1 = [math.fabs(d_mag[i])*20 for i in range(len(d_mag)) if d_mag[i] > 0]
        u2 = [u[i] for i in range(len(d_mag)) if d_mag[i] < 0]
        v2 = [v[i] for i in range(len(d_mag)) if d_mag[i] < 0]
        s2 = [math.fabs(d_mag[i])*20 for i in range(len(d_mag)) if d_mag[i] < 0]

        plt.clf()
        plt.rc('text', usetex=True)

        plt.scatter(u1, v1, s1, color='blue')
        plt.scatter(u2, v2, s2, color='red')
        plt.axes().set_aspect('equal')

        plt.savefig(os.path.join(self.outputDir, "DFlux2D.png"), format='png')

    def outputDiagWcs(self):
        self.log.info("Output Diagnostic Figures...")

        if not os.path.isdir(self.outputDir):
            os.makedirs(self.outputDir)

        f = open(os.path.join(self.outputDir, "coeffs.dat"), "wt")
        for iexp in self.coeffSet.keys():
            c = self.coeffSet[iexp]
            f.write("%ld %12.5e %12.5e\n" % (iexp, c.A,  c.D));
            f.write("%ld %12.5f %12.5f\n" % (iexp, c.x0, c.y0));
            for k in range(c.getNcoeff()):
                f.write("%ld %15.8e %15.8e %15.8e %15.8e\n" % (iexp, c.get_a(k), c.get_b(k), c.get_ap(k), c.get_bp(k)));
        f.close()

        f = open(os.path.join(self.outputDir, "ccd.dat"), "wt")
        for ichip in self.ccdSet.keys():
            ccd = self.ccdSet[ichip]
            center = ccd.getCenter().getPixels(ccd.getPixelSize())
            orient = ccd.getOrientation()
            f.write("%3ld %10.3f %10.3f %10.7f\n" % (ichip, center[0], center[1], orient.getYaw()))
        f.close()

        for iexp in self.coeffSet.keys():
            self.plotJCont(iexp)
            self.plotResPosArrow2D(iexp)

        self.plotResPosScatter()
        self.plotPosDPos()

    def outputDiagFlux(self):
        self.log.info("Output Diagnostic Figures...")

        if not os.path.isdir(self.outputDir):
            os.makedirs(self.outputDir)

        for iexp in self.wcsDic.keys():
            self.plotFCorCont(iexp)

        f = open(os.path.join(self.outputDir, "ccdScale.dat"), "wt")
        for ichip in self.fchip.keys():
            scale = self.fchip[ichip]
            f.write("%3ld %6.3f\n" % (ichip, scale))
        f.close()

        self.plotMdM()
        self.plotResFlux()
        self.plotDFlux2D()

    def flagSuspect(self, allMat, allSource, wcsDic):
        # Wrongly matched objects between visits will destroy ubar-calibration fitting.
        # In this method, determine median magnitude difference between visits and
        # flag (set flux to negative value to be flagged as bad object) objects which
        # show large magnitude difference from median value.
        visits = wcsDic.keys()
        for j in range(len(visits)-1):
            visit_ref = visits[j]
            for i in range(j+1, len(visits)):
                visit_targ = visits[i]
                refs = list()
                targs = list()
                mref  = list()
                mtarg = list()
                for mm in allMat:
                    j_ref = -1
                    j_targ = -1
                    for k in range(1, len(mm)):
                        if mm[k].getExp() == visit_ref:
                            j_ref = k
                        elif mm[k].getExp() == visit_targ:
                            j_targ = k
                    if j_ref != -1 and j_targ != -1 and mm[j_ref].getFlux() > 0 and mm[j_targ].getFlux() > 0:
                        refs.append(mm[j_ref])
                        targs.append(mm[j_targ])
                        mref.append(mm[j_ref].getFlux())
                        mtarg.append(mm[j_targ].getFlux())
                for ss in allSource:
                    j_ref = -1
                    j_targ = -1
                    for k in range(1, len(ss)):
                        if ss[k].getExp() == visit_ref:
                            j_ref = k
                        elif ss[k].getExp() == visit_targ:
                            j_targ = k
                    if j_ref != -1 and j_targ != -1 and ss[j_ref].getFlux() > 0 and ss[j_targ].getFlux() > 0:
                        refs.append(ss[j_ref])
                        targs.append(ss[j_targ])
                        mref.append(ss[j_ref].getFlux())
                        mtarg.append(ss[j_targ].getFlux())

                # There is no overlapping sources
                if len(mref) < 10:
                    print '%d %d' % (visit_ref, visit_targ)
                    continue

                mref = -2.5*numpy.log10(mref)
                mtarg = -2.5*numpy.log10(mtarg)

                dm = mtarg - mref
                med = numpy.median(dm)
                Q1 = numpy.percentile(dm, 10)
                Q3 = numpy.percentile(dm, 90)
                SIQR = 0.5 * (Q3 - Q1)

                #del mref
                #del mtarg
                del dm

                ngood = 0
                nbad  = 0
                for mr, mt, ref, targ in zip(mref, mtarg, refs, targs):
                    if math.fabs(mt-mr-med) > 3.0 * SIQR:
                        ref.setFlux(-9999)
                        targ.setFlux(-9999)
                        nbad += 1
                    else:
                        ngood += 1

                print '%d %d %6.3f %5.3f %5d %5d' % (visit_ref, visit_targ, med, SIQR, ngood, nbad)

                del mref
                del mtarg
                del refs
                del targs

    def checkOverlapWithTract(self, tractInfo, dataRefList, verbose=False):
        dataRefListExists = list()
        dataRefListOverlapWithTract = list()
        tractBBox = afwGeom.Box2D(tractInfo.getBBox())
        tractWcs = tractInfo.getWcs()
        for dataRef in dataRefList:
            try:
                if not dataRef.datasetExists('calexp_md'):
                    raise RuntimeError("no data for calexp_md %s" % (dataRef.dataId))
                md = dataRef.get('calexp_md', immediate=True)
                wcs = afwImage.makeWcs(md)

                dataRefListExists.append(dataRef)

                if self.config.requireTractOverlap:
                    naxis1, naxis2 = md.get('NAXIS1'), md.get('NAXIS2')
                    bbox = afwGeom.Box2D(afwGeom.Box2I(afwGeom.Point2I(0,0), afwGeom.Extent2I(naxis1, naxis2)))
                    overlap = False
                    for corner in bbox.getCorners():
                        if tractBBox.contains(tractWcs.skyToPixel(wcs.pixelToSky(corner))):
                            overlap = True
                            break
                    if overlap:
                        dataRefListOverlapWithTract.append(dataRef)
                    else:  # when there's no break i.e. no corner was in the tract
                        if verbose:
                            self.log.warn("Image %s does not overlap tract %s" % (dataRef.dataId, tractInfo.getId()))
                else:
                    dataRefListOverlapWithTract.append(dataRef)
            except Exception, e:
                print e

        visitListOverlapWithTract = list(set([d.dataId['visit'] for d in dataRefListOverlapWithTract]))

        dataRefListToUse = list()
        for dataRef in dataRefListExists:
            if dataRef.dataId['visit'] in visitListOverlapWithTract:
                dataRefListToUse.append(dataRef)

        return dataRefListOverlapWithTract, dataRefListToUse

    def mosaic(self, dataRefList, tractInfo, ct=None, debug=False, verbose=False):

        self.log.info(str(self.config))

        self.outputDir = os.path.join(self.config.outputDir, "%04d" % tractInfo.getId())

        if ((self.config.outputDiag or self.config.outputSnapshots)
            and not os.path.isdir(self.outputDir)):
            os.makedirs(self.outputDir)

        if self.config.nBrightest != 0:
            self.log.fatal('Config paremeter nBrightest is deprecated.')
            self.log.fatal('Please use cellSize and nStarPerCell.')
            self.log.fatal('Exiting ...')
            return []

        dataRefListOverlapWithTract, dataRefListToUse = self.checkOverlapWithTract(tractInfo, dataRefList)

        sourceSet, matchList, dataRefListUsed = self.readCatalog(dataRefListToUse, ct, verbose)

        dataRefListToOutput = list(set(dataRefListUsed) & set(dataRefListOverlapWithTract))

        ccdSet = self.readCcd(dataRefListUsed)

        if debug:
            for ccd in ccdSet.values():
                self.log.info(str(ccd.getId().getSerial())+" "+
                              str(ccd.getCenter().getPixels(ccd.getPixelSize()))+" "+
                              str(ccd.getOrientation().getYaw()))

        wcsDic = self.readWcs(dataRefListUsed, ccdSet)

        self.removeNonExistCcd(dataRefListUsed, ccdSet)

        if debug:
            for iexp, wcs in wcsDic.iteritems():
                self.log.info(str(iexp)+" "+str(wcs.getPixelOrigin())+" "+
                              str(wcs.getSkyOrigin().getPosition(afwGeom.degrees)))

        self.log.info("frameIds : "+str(wcsDic.keys()))
        self.log.info("ccdIds : "+str(ccdSet.keys()))

        d_lim = afwGeom.Angle(self.config.radXMatch, afwGeom.arcseconds)
        if debug:
            self.log.info("d_lim : %f" % d_lim)

        allMat, allSource =self.mergeCatalog(sourceSet, matchList, ccdSet, d_lim)

        self.log.info("Flag suspect objects")
        #self.flagSuspect(allMat, allSource, wcsDic)
        measMosaic.flagSuspect(allMat, allSource, wcsDic)

        if self.config.clipSourcesOutsideTract:
            tractBBox = afwGeom.Box2D(tractInfo.getBBox())
            tractWcs = tractInfo.getWcs()
            allSourceClipped = measMosaic.SourceGroup([ss for ss in allSource if tractBBox.contains(tractWcs.skyToPixel(ss[0].getSky()))])
            self.log.info("Num of allSources: %d" % (len(allSource)))
            self.log.info("Num of clipped allSources: %d" % (len(allSourceClipped)))
            allSource = allSourceClipped

        self.log.info("Make obsVec")
        nmatch  = allMat.size()
        nsource = allSource.size()
        matchVec  = measMosaic.obsVecFromSourceGroup(allMat,    wcsDic, ccdSet)
        sourceVec = measMosaic.obsVecFromSourceGroup(allSource, wcsDic, ccdSet)

        self.log.info("Solve mosaic ...")
        order = self.config.fittingOrder
        internal = self.config.internalFitting
        solveCcd = self.config.solveCcd
        allowRotation = self.config.allowRotation
        fluxFitOrder = self.config.fluxFitOrder
        chebyshev = self.config.chebyshev
        absolute = self.config.fluxFitAbsolute
        solveCcdScale = self.config.fluxFitSolveCcd
        catRMS = self.config.catRMS

        if not internal:
            sourceVec = measMosaic.ObsVec()

        if debug:
            self.log.info("order : %d" % ffp.order)
            self.log.info("internal : %r" % internal)
            self.log.info("solveCcd : %r " % solveCcd)
            self.log.info("allowRotation : %r" % allowRotation)

        self.matchVec = matchVec
        self.sourceVec = sourceVec
        self.wcsDic = wcsDic
        self.ccdSet = ccdSet

        if self.config.doSolveWcs:

            if internal:
                coeffSet = measMosaic.solveMosaic_CCD(order, nmatch, nsource,
                                                      matchVec, sourceVec,
                                                      wcsDic, ccdSet, #ffpSet, fexp, fchip,
                                                      solveCcd, allowRotation, #solveCcdScale,
                                                      verbose, catRMS,
                                                      self.config.outputSnapshots, self.outputDir)
            else:
                coeffSet = measMosaic.solveMosaic_CCD_shot(order, nmatch, matchVec, 
                                                           wcsDic, ccdSet, #ffpSet, fexp, fchip,
                                                           solveCcd, allowRotation, #solveCcdScale,
                                                           verbose, catRMS,
                                                           self.config.outputSnapshots, self.outputDir)

            self.coeffSet = coeffSet

            self.writeNewWcs(dataRefListToOutput)

            if self.config.outputDiag:
                self.outputDiagWcs()

            for m in matchVec:
                coeff = coeffSet[m.iexp]
                scale = coeff.pixelScale()
                m.mag -= 2.5 * math.log10(coeff.detJ(m.u, m.v) / scale**2)

            if sourceVec.size() != 0:
                for s in sourceVec:
                    coeff = coeffSet[s.iexp]
                    scale = coeff.pixelScale()
                    s.mag -= 2.5 * math.log10(coeff.detJ(s.u, s.v) / scale**2)

        else:

            wcsAll = dict()

            for dataRef in dataRefListUsed:
                frameId = '%07d-%03d' % (dataRef.dataId['visit'], dataRef.dataId['ccd'])
                md = dataRef.get('calexp_md')
                wcsAll[frameId] = afwImage.makeWcs(md)
                del md

            for m in matchVec:
                wcs = wcsAll['%07d-%03d' % (m.iexp, m.ichip)]
                scale = wcs.pixelScale().asDegrees()
                m.mag -= 2.5 * math.log10(wcs.pixArea(afwGeom.Point2D(m.x, m.y)) / scale**2)

            if sourceVec.size() != 0:
                for s in sourceVec:
                    wcs = wcsAll['%07d-%03d' % (s.iexp, s.ichip)]
                    scale = wcs.pixelScale().asDegrees()
                    s.mag -= 2.5 * math.log10(wcs.pixArea(afwGeom.Point2D(s.x, s.y)) / scale**2)

            del wcsAll

        if self.config.doSolveFlux:

            ffpSet = measMosaic.FfpSet()
            for visit in wcsDic.keys():
                ffp = measMosaic.FluxFitParams(fluxFitOrder, absolute, chebyshev)
                u_max, v_max = self.getExtent(matchVec)
                ffp.u_max = (math.floor(u_max / 10.) + 1) * 10
                ffp.v_max = (math.floor(v_max / 10.) + 1) * 10
                ffpSet[visit] = ffp

            fexp = measMosaic.map_int_float()
            fchip = measMosaic.map_int_float()

            measMosaic.fluxFit(absolute, self.config.commonFluxCorr, matchVec, nmatch, sourceVec, nsource, wcsDic, ccdSet,
                               fexp, fchip, ffpSet, solveCcdScale)

            self.ffpSet = ffpSet
            self.fexp = fexp
            self.fchip = fchip

            self.writeFcr(dataRefListToOutput)

            if self.config.outputDiag:
                self.outputDiagFlux()

        if self.config.outputDiag and self.config.doSolveWcs and self.config.doSolveFlux:
            if sourceVec.size() != 0:
                self.writeCatalog(matchVec, sourceVec, coeffSet,
                                  os.path.join(self.outputDir, "catalog.fits"))

        return wcsDic.keys()

    def writeCatalog(self, matchVec, sourceVec, coeffSet, name):
        # count number of unique objects
        idList = list()
        for m in matchVec:
            if not m.istar in idList:
                idList.append(m.istar)
        num_m = len(idList)
        idList = list()
        for s in sourceVec:
            if not s.istar in idList:
                idList.append(s.istar)
        num_s = len(idList)
        num = num_m + num_s

        ra  = numpy.zeros(num, dtype=numpy.float64)
        dec = numpy.zeros(num, dtype=numpy.float64)
        mag = numpy.zeros(num, dtype=numpy.float64)
        var = numpy.zeros(num, dtype=numpy.float64)
        err = numpy.zeros(num, dtype=numpy.float64)
        numbers = numpy.zeros(num, dtype=numpy.int32)

        numGood = 0
        for m in matchVec:
            if (not m.good or m.jstar == -1 or
                m.mag == -9999 or m.err == -9999 or
                m.mag_cat == -9999):
                continue

            index = m.istar

            if numbers[index] == 0:
                numGood += 1

            # Deproject m.{xi,eta}_fit
            crval = [coeffSet[m.iexp].A, coeffSet[m.iexp].D]
            x = math.radians(m.xi_fit)
            y = math.radians(m.eta_fit)
            radius = math.hypot(x, y)
            sinPhi, cosPhi = x/radius, y/radius
            rho = math.sqrt(1.0 + radius**2)
            sinTheta, cosTheta = 1.0/rho, radius/rho
            sinD, cosD = math.sin(crval[1]), math.cos(crval[1])
            dec[index] += math.asin(sinTheta*sinD + cosTheta*cosPhi*cosD)
            sinAlpha = cosTheta*sinPhi
            cosAlpha = -cosTheta*cosPhi*sinD + sinTheta*cosD
            ra[index] += math.atan2(sinAlpha, cosAlpha) + crval[0]

            exp_cor = -2.5 * math.log10(self.fexp[m.iexp])
            chip_cor = -2.5 * math.log10(self.fchip[m.ichip])
            gain_cor = self.ffpSet[m.iexp].eval(m.u, m.v)
            mag_cor = m.mag + exp_cor + chip_cor + gain_cor

            mag[index] += mag_cor / m.err**2
            var[index] += mag_cor * mag_cor / m.err**2
            err[index] += (1.0 / m.err**2)
            numbers[index] += 1

        # Take a mean of individual measurements
        ra /= numbers
        dec /= numbers
        mag /= err
        err = numpy.sqrt((var - mag * mag * err) / err)

        for s in sourceVec:
            if (not s.good or s.jstar == -1 or
                s.mag == -9999 or s.err == -9999):
                continue

            index = s.istar + num_m

            if numbers[index] == 0:
                numGood += 1

                # For sourceVec, fitted values are stored.
                # So simply take them.
                mag[index] = s.mag0
                ra[index] = s.ra
                dec[index] = s.dec
                err[index] = 0.0

            else:
                assert mag[index] == numpy.float64(s.mag0), "Discrepancy between solved magnitudes"
                assert ra[index] == numpy.float64(s.ra), "Discrepancy between solved positions"
                assert dec[index] == numpy.float64(s.dec), "Discrepancy between solved positions"

            # For error, calculate RMS around fitted values
            exp_cor = -2.5 * math.log10(self.fexp[s.iexp])
            chip_cor = -2.5 * math.log10(self.fchip[s.ichip])
            gain_cor = self.ffpSet[s.iexp].eval(s.u, s.v)
            mag_cor = s.mag + exp_cor + chip_cor + gain_cor
            var[index] += ((mag_cor-s.mag0)/s.err)**2
            err[index] += (1.0 / s.err**2)
            numbers[index] += 1

        err[num_m:] = numpy.sqrt(var[num_m:]/err[num_m:])

        schema = afwTable.SimpleTable.makeMinimalSchema()
        magKey = schema.addField("mag", type="F", doc="Magnitude")
        errKey = schema.addField("err", type="F", doc="Magnitude error")
        numKey = schema.addField("num", type="I", doc="Number of observations")
        catalog = afwTable.SimpleCatalog(schema)
        catalog.reserve(numGood)
        for i in range(num):
            if numbers[i] == 0:
                continue
            r = catalog.addNew()
            r.setId(i)
            r.setCoord(afwCoord.Coord(ra[i]*afwGeom.radians, dec[i]*afwGeom.radians))
            r.set(magKey, float(mag[i]))
            r.set(errKey, float(err[i]))
            r.set(numKey, int(numbers[i]))

        catalog.writeFits(name)


    def run(self, camera, butler, tract, dataRefList, debug, verbose=False):
        self.log.info("Running self-calibration for tract %d" % tract)
        skyMap = butler.get("deepCoadd_skyMap", immediate=True)
        tractInfo = skyMap[tract]

        filters = list()
        for dataRef in dataRefList:
            if not dataRef.dataId['filter'] in filters:
                filters.append(dataRef.dataId['filter'])

        if len(filters) != 1:
            self.log.fatal("There are %d filters in input frames" % len(filters))
            return None

        if self.config.doColorTerms and self.config.photoCatName:
            ct = self.config.colorterms.getColorterm(filters[0], self.config.photoCatName)
            self.log.info('color term: '+str(ct))
        elif self.config.doColorTerms:
            ct = None
            self.log.warn("Cannot apply color term: reference catalog not specified")
        else:
            ct = None
            self.log.info("Not applying color term")

        return self.mosaic(dataRefList, tractInfo, ct, debug, verbose)
